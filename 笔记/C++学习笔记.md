---
title: C++学习笔记
tags: C++
grammar_cjkRuby: true
---
## C++ 初步

### C++ 的标准库与命名空间

1. 为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。每个独立的命名空间可以包含相同名称的变量。命名空间中可以包含变量、函数、类、`typedef`、`#define`等。最后由`{}`包围。
	```c++
	namespace Li {
		FILE fp = NULL;
	}
	namespace Han {
		FILE fp = NULL;
	}
	```
	要使用命名空间中的成员，有两种方式：
	+ 使用作用域运算符`::`。
		```c++
		Li :: fp  = fopen("one.txt", "r");
		Han :: fp = fopen("two.txt", "rb+");
		```
	+ 采用`using`声明。
		```c++
		using Li :: fp;
		fp = fopen("one.txt", "r");
		```
		或者
		```c++
		using namespace Li;
		fp = fopen("one.txt", "r");
		```
	
2. 作用域解析运算符（`::`）
	作用域解析运算符使用方法如下：
	​	+ `域名::函数/类型定义`：表示定义某个域的函数/类型。常用于在类外定义类成员或类方法，或命名空间内成员的使用。
	​	+ `::函数/类型调用`：表示调用全局的函数/类型。

### 变量

1. 相比于C只是用1和0代表“真”和“假”，在C++ 中新增了`bool`类型（true和false）用来表示“真”和“假”，一般占用1个字节长度。但是在C++ 中使用cout输出bool变量的值时还是使用数字1和0。

### new和delete操作符

1. 在C语言中，动态分配内存用`malloc()`函数，释放内存用`free()`函数。
	```C
	int *p = (int*) malloc(sizeof(int) * 10);  // 分配10个int型的内存空间
	free(p);  // 释放内存
	```
	在C++ 中仍然可以使用这种方式。但更好的方式是使用`new`和`delete`两个操作符分配和释放内存。它们可以**自动调用**构造函数和析构函数。
	```C++
	int *p = new int[10];
	delete p;
	```
	
### inline内联函数

1. 函数调用是有时间和空间开销的。如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分时间会花费在函数调用机制上。
	为了消除函数调用的时空开销，C++ 提供了**内联函数**方法（类似于C语言中的宏展开），在编译时编译器会将函数调用处的代码直接替换成内联函数的函数体。只需要在函数**定义**处增加关键字**inline**。
	```c++?linenums
	#include <iostream>
	using namespace std;
	
	// 内联函数
	inline void swap(int *a, int *b) {
		int temp;
		temp = *a;
		*a = *b;
		*b = temp;
	}
	
	int main() {
		int m, n;
		cin >> m >> n;
		swap(&m, &n);
		cout << m << "," << n << endl;
		return 0;
	}
	```
	这样第15行程序`swap(&m, &n)`就会被替换成：
	```c++
	int temp;
	temp = *(&m);
	*(&m) = *(&n);
	*(&n) = temp;
	```
	从而在执行程序时提高效率。
	*注：*
	+ 在函数声明处添加inline关键字是无效的，编译器会忽略声明处关键字。
	+ 一般只将短小的、频繁调用的函数声明为内联函数。

### 函数的默认参数

1. C++ 规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的形参都必须是默认值。

### 函数重载

1. 在C++中，允许多个函数拥有相同的名字，只要他们的参数列表不同就可以。这就是**函数重载**。参数列表又叫参数签名，包括参数的**类型**、参数的**个数**和参数的**顺序**。参数的返回值不能作为重载的依据。
2. C++ 代码在编译时会根据参数列表对函数进行重命名，例如`void swap(int a, int b)`会被重命名为`_swap_int_int`，`void swap(float x, float y)`会被重命名为`_swap_float_float`，当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数。从这个角度讲，函数重载仅仅是**语法层面**的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

## C++ 内存管理

### 概念

在C++中，内存被分成5个区，分别是：

1. 栈
	就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。
2. 堆
	就是那些由`new`或`malloc`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个`delete`（同样一个`malloc`对应一个`free`）。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
3. 代码区
	存储所有函数体的二进制代码。
4. 全局/静态存储区
	全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言堆栈中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 `void*` 来访问和操纵，程序结束后由系统自行释放），在C++ 里面没有这个区分了，他们共同占用同一块内存区。
5.  常量存储区
	常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改(当然，你要通过非正当手段也可以修改，而且方法很多)。

> 注：部分博客中分区方法为将代码区替换成自由存储区，这是一种错误的分区方式。因为new和malloc一样都是使用的堆内存。

### 堆和栈的区别

1. 管理方式
	对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生`memory leak`。
2. 空间大小
	一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。（这个值可以通过编译器修改）。当然，我们可以修改：打开工程，依次操作菜单如下：`Project->Setting->Link`，在 `Category` 中选中 `Output`，然后在 `Reserve` 中设定堆栈的最大值和 `commit`。注意：`reserve` 最小值为 4Byte；`commit` 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。
3. 碎片问题
	对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。
4. 生长方向
	对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. 分配方式
	堆都是**动态分配**的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是**编译器**完成的，比如**局部变量**的分配。**动态分配**由 `malloc` 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由**编译器**进行释放，无需我们手工实现。
6. 分配效率
	栈是**机器系统**提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了**栈的效率比较高**。堆则是**C/C++** 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，**堆的效率比栈要低得多**。

## C++ 类和对象

### 类的定义和对象的创建

1. 类使用户自定义的类型，程序中的类要么提前说明，要么使用已经存在的类（如别人写好的类、标准库中的类等），C++ 语法本身不提供现成的类名称、结构和内容。
2. 类只是一个模版，编译后不占用内存空间，因此在定义类时不能对成员变量进行初始化。只有创建对象后才能给成员变量分配内存，此时才能可以赋值。
3. 创建的对象可以通过`对象名.成员`的方式访问成员变量或成员函数。
4. 使用对象指针
	如果在**栈**中创建了对象，则使用对象指针时用`&`获取对象地址。如果在**堆**上创建对象，则必须使用指针指向它。因为通过`new`在堆上创建的对象是**匿名**的，必须使用一个指针指向它，再借助指针访问它的成员变量或成员函数。对象指针通过箭头`->`来访问对象的成员变量和成员函数。

### C++ 类的成员变量和成员函数

1. 成员函数必须先在类体中作原型声明，然后才能在类外定义，也就是说类体位置在类函数定义之前。
2. 在类体中和类体外定义成员函数是有区别的：在**类体内**定义的成员函数会自动成为**内联函数**，在**类体外**定义的**不会**。

	**内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯。**

	当然，如果函数比较短小，希望定义为内联函数也是可以的。
	
	如果希望将定义在类体外部的函数定义为内联函数，则可以在定义函数时加`inline`关键字。这种在类体外定义`inline`函数的方式，必须将类的定义和成员函数的定义放在同一个头文件/源文件中，否则编译时无法进行嵌入。
	```c++
	class Student {
	public:
		char *name;
		int age;
		float score;
		
		void say();
	};
	
	inline void Student::say() {
		cout << name << age << score << endl;
	}
	```

### C++ 类的成员访问权限

1. 类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在**头文件**中。而将成员函数的定义放在**源文件**中。
2. 在实际编码中，成员变量通常以`m_`开头或者以`_`结尾，例如`m_name`, `age_`等。这样既可以直接看出是成员变量，又可以和成员函数中的形参名区分开。
3. 通常操作声明为`private`的成员变量，可以通过声明为`public`属性的`set`函数和`get`函数。一般命名为`set+成员变量名()`和`get+成员变量名()`，例如`setname()`, `getname`等。
4. 如果没有声明成员的访问权限，则默认为**private**。

### C++ 对象的内存模型

1. 类是创建对象的模板，**不占用内存空间，不存在于编译后的可执行文件中**；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。
2. 编译器会将成员变量和成员函数分开存储，分别为每个对象的成员变量分配内存。而所有对象都共享同一段函数代码。

	![C++ 对象的内存模型](http://c.biancheng.net/cpp/uploads/allimg/150909/1-150Z9134434637.png)
	实例：
	```c++
	class Student {
	private:
		string name_;
		int age_;
		float score_;
	public:
		void show();
	}
	void Student::show() { ... }
	int main() {
		Student stu;
		cout << sizeof(stu) << endl;
		Student *pstu = new Student();
		cout << sizeof(*pstu) << endl;
		cout << sizeof(Student) << endl;
		return 0;
	}
	```
	结果将输出3个12。分别是string, int, float三个变量占用的内存（由于内存对齐总共为12个字节）。说明对象所占用的内存仅仅包含了成员变量。

### C++ 函数编译原理和成员函数的实现

1. C++ 和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线`_`（不同的编译器有不同的实现），例如，`func()`编译后为`func()`或`_func()`。
	而C++ 中的函数在编译时会根据它所在的**命名空间**、**它所属的类**、以及它的**参数列表**（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做**名字编码（Name Mangling）**，是通过一种特殊的算法来实现的。
2. 成员函数最终会被编译成与对象无关的**全局函数**。
3. 为了能在编译后的成员函数中使用成员变量，C++ 规定编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针访问成员变量。例如
	```c++
	void Demo::Display() {
		cout << a << endl;
	}
	```
	编译后代码类似于
	```c++
	void new_function_name(Demo * const p) {
		// 通过指针p访问成员变量
		cout << p->a << endl;
	}
	```
	调用时，调用函数会变成以下形式：
	```c++
	new_function_name(&obj);
	```
	
### C++ 构造函数（Constructor）

1. 构造函数名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。
2. 构造函数必须是`public`属性的，否则创建对象时无法调用。
3. 构造函数**没有返回值**，因为没有变量来接收返回值。这意味着：
	+ 不管声明还是定义，构造函数名前面都不能初见返回值类型，即使是`void`也不允许
	+ 构造函数体中不能有`return`语句
4. 如果用户没有定义构造函数，则编译器会自动声明一个默认的构造函数。一旦用户自己定义了 构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
5. 调用没有参数的构造函数可以**省略括号**。例如可以写作`Student stu`或`Student *pstu = new Student`。

### 构造函数的参数初始化表

1. 举例
	```c++
	Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score) {
		// ...
	}
	```
2. 使用参数初始化表并没有效率上的优势，仅仅是书写方便。
3. 参数初始化表可以只用于**部分变量**。
4. 参数初始化顺序与初始化表列出变量的顺序无关，只与成员变量在**类中声明的顺序**有关。例如
  ```c++
  class Demo {
  private:
  	int m_a;
  	int m_b;
  public:
  	Demo(int b);
  	void show();
  };
  
  Demo::Demo(int b): m_b(b), m_a(m_b) {}
  //...
  ```
  在这里我们将`m_b`放在`m_a`前面，看起来是先给`m_b`赋值，再给`m_a`赋值。实际上成员变量的赋值顺序是由他们在类中声明的顺序决定的。因此上面的构造函数等价于
  ```c++
  Demo::Demo(int b): m_b(b), m_a(m_b) {
  	m_a = m_b;
  	m_b = b;
  }
  ```
  由于给`m_a`赋值时`m_b`还未初始化，因此会输出一个奇怪的数值。

  > obj在栈上分配内存，成员变量的初始值是不确定的。

5. 初始化`const`成员变量的唯一方法是使用参数初始化表。
	```c++
	class VLA {
	private:
		const int m_len;
		int *m_arr;
	public:
		VLA(int len);
	};
	
	// 这里必须用参数初始化表来初始化m_len，如果在VLA函数体内部初始化m_len则会报错
	VLA::VLA(int len):m_len(len) {
		m_arr = new int[len];
	}
	```
	
### 析构函数（Destructor）

1. 析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。
2. 析构函数没有参数，不能被重载。因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
3. C++ 中的`new`和`delete`与C语言中的`malloc()`和`free()`最大的一个不同之处在于：用`new`分配内存会调用构造函数，用`delete`释放内存时会调用析构函数，因此在C++ 中鼓励使用`new`和`delete`。
4. 析构函数的执行时机
	+ 所有函数之外创建的对象：全局对象，位于内存分区中的**全局数据区**。程序在结束执行时会调用这些对象的析构函数。
	+ 在函数内部创建的对象：局部对象，位于**栈区**。函数执行结束时会调用这些对象的析构函数。
	+ `new`创建的对象：位于**堆区**。通过`delete`删除时才会调用析构函数。如果没有`delete`，析构函数就不会执行。

### this指针

1. `this`时C++ 中的一个关键字，也是一个**const指针**，它指向当前对象。通过它可以访问当前对象的所有成员。
2. `this`是一个指针，要用`->`来访问成员变量和成员函数。
3. `this`只在对象被创建以后才会给`this`赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给`this`赋值。如果使用对象指针创建对象，则`this`的值和指针的值是相同的（指向同一个地址）。例如
	```c++
	class Student() {
	public:
		void printThis();
	};
	Student::printThis() {cout << this << endl;}
	
	int main() {
		Student *pstu = new Student();
		pstu -> printThis();
		cout << pstu << endl;
		
		return 0;
	}
	```
	结果将会打印两个相同的16进制地址。
4. `this`只能在**成员函数**内部使用，用在其他地方没有意义，也是非法的。
5. 只有对象创建后`this`采用意义，因此不能在`static`成员函数中使用。
6. `this`实际上是成员函数的一个**形参**，在调用成员函数时将**对象的地址**作为实参传递给`this`。不过`this`这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
	`this`本质上是成员函数的局部变量，所以只能用在成员函数内部，并且只有在通过对象调用成员函数时才给`this`赋值。
	成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是`this`，它是成员函数和成员变量关联的桥梁。

### static静态成员变量

1. 当我们需要在多个对象之间共享数据时，可以通过静态成员变量实现，它通过关键字`static`修饰。
2. `static`成员变量属于类，不属于某个具体的对象。初始化后只会分配一份内存，所有对象使用的都是这份内存中的数据。
3. `static`成员变量必须在**类声明的外部**初始化。
	```c++
	type class::name = value;
	```
	`type`时变量的类型（如int, float等），class是类名。
	静态成员变量在初始化时不能再加`static`，但必须有数据类型。
4. `static`成员变量的内存是在类外初始化时分配的。
5. `static`成员变量可以通过类、对象、对象指针访问。
	```c++
	// 通过类访问
	Student::m_total = 10;
	// 通过对象访问
	Student stu();
	stu.m_total = 20;
	// 通过对象指针访问
	Student *pstu = new Student();
	pstu -> m_total = 20;
	```
6. `static`成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，`static`成员变量和普通的`static`变量类似，都在内存分区中的**全局数据区**分配内存，到程序结束时才释放。
7. 静态成员变量必须初始化，初始化时可以赋值，如果不赋值则默认初始化为0。全局数据区的变量都有默认的初始值0，而动态数据区（堆区、栈区）变量的默认值时不确定的。

### static静态成员函数

1. 普通成员函数可以访问所有成员，静态成员函数只能访问静态成员。这在代码上使得只需要操作静态成员变量的函数语义更明确。
2. 编译器在编译一个普通成员函数时，会隐式地增加一个形参`this`，并把当前对象的地址赋值给`this`，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参`this`，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。
3. 和静态成员变量类似，静态成员函数在声明时要加`static`，在定义时不能加 `static`。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用。

### const关键字

1. `const`成员函数可以使用类中的所有成员变量，但**不能修改它们的值**。`const`成员函数也称为**常成员函数**。`const`对象**必须初始化**，初始值可以是任何复杂的表达式：
	```c++
	const int i = get_size(); // 正确，运行时初始化
	const int j = 42; // 正确，编译时初始化
	const int k; // 错误，k是一个未经初始化的变量
	```
2. 必须在成员函数的**声明**和**定义**处同时加上`const`关键字。
	```c++
	class Student {
	public:
		Student(char *name);
		// 声明时要加上const
		void show *getname() oncst;
	private:
		char *m_name;
	}
	
	// 定义时也要加上const
	char * Student::getname() const {
		return m_name;
	}
	```
3. `const`也可以用来修饰对象，称为**常对象**，常对象只在定义时需要用`const`定义。一旦将对象定义为常对象后，就只能调用类的`const`成员了。
	```c++
	// 定义常对象
	const className objectName(params);
	className const objectName(params);
	
	// 定义const对象指针
	const className *p = new className(params);
	className const *p = new className(params);
	```
4. `const`也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。`const`和指针一起使用会有几种不同的顺序，如下所示：
	```c++
	// 限制p1, p2指向的数据
	const int *p1;
	int const *p2;
	
	// 限制p3指针
	int * const p3;
	
	// 同时限制指针本身与指向的数据
	const int * const p4;
	int const * const p5;
	```
	`const`离变量名近（紧邻变量名）就是用来修饰指针变量的，离变量名远（中间有其他的操作符如`*`）就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。
5. `const`通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用`const`来限制。
6. 默认状态下，const对象仅在**当前文件**内有效。编译器在编译过程中把用到const变量的地方全部替换成对应的值。如果程序包含多个文件，则每个用了const对象的文件都必须能访问到它的初始值才行，要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。为了避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。如果多个文件中出现了同名的const变量，其实等同于在不同文件中分别定义了独立的变量。
	想在多个文件中实现const变量的共享，解决办法是对于const变量不管是声明还是定义都添加**extern**关键字，这样只需定义一次就可以了：
	```c++
	// 在file_1.cc中初始化一个常量
	extern const int bufSize = fcn();
	// 在file_1.h头文件中声明
	extern const int bufSize;
	```
7. **对常量的引用**不能被用作修改它所绑定的对象：
	```c++
	cosnt int ci = 1024;
	cosnt int &r1 = ci;
	r1 = 42; // 错误，r1是对敞亮的引用
	int &r2 = ci; // 错误，试图让一个非常量引用指向一个常量对象
	```
8. `const`和`#define`的区别：
	+ const定义的只读变量在程序运行过程中只有**一份拷贝**，而`#define`定义的宏变量在内存中有**若干份拷贝**。（为什么？）
	+ `#define`在**预编译**阶段进行替换，而`const`修饰的只读变量是在**编译**阶段的时候确定其值。
	+ `#define`不进行类型检查，而`const`定义的常量是由类型的，因此编译器会进行类型检查。
	+ `const`可以调试，`#define`不能被调试。

### friend友元函数和友元类

1. 借助友元`friend`，可以使其他类中的成员函数以及全局范围内的函数访问当前类的`private`成员。
2. 友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。成员函数在调用时会隐式地增加`this`指针，指向调用它的对象，从而使用该对象的成员；而友元函数是**非成员函数**，没有`this`指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过**参数传递对象**（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时**指明对象**。
	```c++
	class Student {
	public:
		Student(string name, int age, float score);
		// 声明友元函数
		friend void show(Student *pstu);
	private:
		string m_name;
		int m_age;
		float m_score;
	}
	
	//...
	
	// 定义友元函数，友元是非成员函数，必须借助对象（对象名、引用或指针）才能调用类私有变量
	void show(Student *pstu) {
		cout << pstu->m_name << pstu->m_age << m_score << endl;
	}
	
	int main() {
		Student stu("mei", 21, 93);
		// 调用友元函数
		show(&stu);
		return 0;
	}
	```
3. 友元类中的所有成员函数都是另外一个类的友元函数。如果将类B声明为类A的友元类，则类B中所有成员函数都是类A的友元函数，可以访问类A的**所有成员**，包括`public`，`protected`，`private`属性的。
	```c++
	// 由于在Student类中使用了Address类，因此需要提前声明
	class Address;
	
	class Student {
		// ...
	}
	class Address {
	public:
		//...
		friend class Student;
	private:
		//...
	}
	```
	以上声明完成后，Student类能够使用Address类中所有成员。
4. 友元的关系是**单向的**而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
5. 友元的关系**不能传递**。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。
6. 除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。

### string字符串

1. C++ 中`string`结尾没有结束标志`\0`。
2. 虽然C++ 提供了`string`类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，`string`类为我们提供了一个转换函数`c_str()`，该函数能够将`string`字符串转换为C风格的字符串，并返回该字符串的`const`指针（`const char*`）。
	```c++
	string path = "D:\\demo.txt";
	FILE *fp = fopen(path.c_str(), "rt");
	```
	为了使用C语言中的`fopen()`函数打开文件，必须将`string`字符串转换为C风格的字符串。
3. `string`字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。`string`字符串的起始下标仍是从0开始。
4. string字符串包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。
	+ 插入字符串
		`insert()`函数可以在`string`字符串中指定的位置插入另一个字符串。原型为`string& insert (size_t pos, const string& str);`。`pos`表示要插入的位置，也就是下标；`str`表示要插入的字符串，它可以是string字符串，也可以是C字符串。例如：
		```c++
		int main() {
			string s1, s2, s3;
			s1 = s2 = "12345678";
			s3 = "aaa";
			s1.insert(5, s3);
			s2.insert(6, "bbb");
		}
		```
	+ 删除字符串
		`erase()`可以删除string中的一个子字符串。其原型为`string& erase (size_t pos = 0, size_t len = npos);`。`pos`表示要删除子字符串的起始下标。`len`表示要删除子字符串的长度。如果不指定`len`，则直接删除从`pos`到字符串结束的所有字符。
	+ 提取字符串
		`substr()`可以从string中提取子字符串。原型为`string substr (size_t pos = 0, size_t len = npos) const;`。`pos`为提取子字符串的起始下标，`len`为要提取的字符串长度。
	+ 字符串查找
		+ `find()`函数：用于在string字符串中查找子字符串出现的位置。原型为`size_t find (const string& str, size_t pos = 0) const;`。第一个参数为待查找的字符串，第二个参数为开始查找的位置（下标）。如果不指明，则从第0个开始查找。最终返回的结果时子字符串**第一次**出现在字符串中的起始下标。
		+ `rfind()`函数：`find()`函数从第二个参数开始往后查找，而`rfind()`函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回`-1`。
		+ `find_first_of()`函数：用于查找A字符串和B字符串共同具有的字符第一次在**A字符串**中出现的位置。用法如下：
			```c++
			string s1 = "first b second a";
			string s2 = "ab";
			cout << s1.find_first_of(s2) << endl;
			```
			结果返回6。即两个字符串共有的字符在s1中第一次出现的位置。
			
## C++ 引用

### 引用的概念与基本使用

1. `C/C++`禁止在函数调用时直接传递数组的内容，而是强制传递数组指针。例如将数组作为函数参数时，函数声明可以写成以下几种形式：

  ```c++
  // 形参为数组指针
  int max(int *intArr, int len) { ... }
  // 形参为数组名
  int max(int intArr[6], int len) { ... }
  // 形参为数组名且省略长度
  int max(int Arr[], int len) { ... }
  ```
  事实上后两种形式的数组定义都是假象，编译器会将它们转换为`int *intArr`这样的指针。这是为了防止在进行内存拷贝时，数组过大拖慢程序的效率。

2. 对于对象和结构体，调用函数时既可以传递指针，也可以直接传递内容。为了提高效率，最好传递指针。

3. 在C++ 中，有一种比指针更加快捷的传递聚合类型（如数组、结构体、对象）的方式，那就是引**引用(Reference)** 。 

4. 引用必须在**定义** 时初始化，并且以后也从一而终，不能再引用其他数据。使用引用传参在使用形式上比指针更加直观，一般可以代替指针，值得在编程中大量使用。

5. 如果不希望通过引用来修改原始的数据，可以在定义时添加`const`限制。
  ```c++
  const int &age = 23;
  int const &age = 23;
  ```

6. 将引用作为函数返回值时应注意，不能返回**局部数据**（例如局部变量、局部对象、局部数组等），C++ 编译器检测到该行为时会给出警告。

7. 引用与指针的联系与区别
  在C++ 底层中，引用是通过**指针**实现的，在实现层面上，引用就是指针。但从C++ 程序语言层面上来说，引用**不是实体类型**（不为引用单独分配内存空间）。因此引用与指针的主要区别体现在以下几个方面：

  + 存在空指针，但不存在空引用
    ```c++
    void *a;  // 空指针，合法
    void& b;  // 空引用，不合法
    ```

  + 指针可以不初始化，而引用必须**初始化**。引用的目标一旦确定就不能再更改，而指针可以更改指向目标。

  + 存在指针数组，不存在引用数组。

8. 由于`C++`对形参的转化机制的存在，在传递**二维（或更高维）数组**时，如果直接用数组名作为函数形参，必须**指定除第1维外的所有维度**，这对程序的实现带来了很多不便。因此可以使用**多维指针数组**的方法，使给函数传参时可以直接传递指针，而不必指定维度。例如：

   ```c++
   // 函数形参中不指定维度
   int func(**array)
   { 
       ...
   }
   
   // 原数组
   int maze[5][5] = {
       {0, 0, 1, 1, 1},
       {0, 0, 0, 1, 1},
       {0, 1, 0, 1, 1},
       {0, 0, 0, 1, 1},
       {0, 0, 0, 0, 0}
   };
   int m = 5, n = 5;
   // 创建一个二维指针数组，new出m个指针，m为行数
   int **maze2d = new int *[m];
   // m个指针分别指向原数组第i行的起始位置（也就是编译器中寻址的原理）
   for(int i = 0; i < m; i++)
   {
       maze2d[i] = (int *)maze + i * n;
   }
   
   // 调用时可以直接将二维指针数组作为实参传递，且在函数中可以直接使用下标操作原数组中的元素
   func(maze2d);
   ```


## C++ 继承与派生

### 继承的概念与语法

1. 继承的方式包括`public`，`private`和`protected`。如果不写，则默认为`private`。
2. 如果希望基类的成员不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为`protected`。
3. 基类的`private`成员不能在派生类中使用，但是**会被继承**，会占用派生类对象的内存，只是在派生类中**不可见**，因此无法使用。
4. 使用`using`关键字可以改变基类成员在派生类中的访问权限，例如将`public`改为`private`，将`private`改为`public`。用法如下：
	```c++
	// 基类
	class People {
	public:
		void Show();
	private:
		string name_;
		int age_;
	};
	
	// 派生类
	class Student: public People {
	public:
		void Learning();
		// using 基类名::变量名，写在要变成的访问权限声明下
		using People::name_;
		using People::age_;
	private:
		// 成员函数改变访问权限时不需要加上形参
		using People::Show;
	};
	```

### 继承时的名字遮蔽

1. 当派生类中的成员和基类中的成员重名时，就会**遮蔽**从基类继承过来的成员，即在派生类定义或通过派生类对象访问该成员时，实际上使用的是派生类新增的成员。
2. 可以通过加上**类名**和**域解析操作符**访问基类的被遮蔽的成员。
	```c++
	class People {
	public:
		void show();
	};
	class Student: public People {
	public:
		void show();
	};
	int main {
		Student stu();
		// 使用的是派生类中的成员函数
		stu.show();
		// 使用的是基类中继承来的成员函数
		stu.People::show();
		return 0;
	}
	```
3. 基类成员函数和派生类成员函数**不构成重载**，只要名字一样就会造成遮蔽，不管它们的参数是否一样。

### 类继承时的作用域嵌套

1. 类也是一种**作用域**，每个类都会定义自己的作用域，在这个作用域内再定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义。这个过程叫做**名字查找(name lookup)**,也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程。因此对于成员函数，编译器是根据**函数的名字**查找的，不会理会函数的参数。因此，只有在一个作用域内的同名函数才具有重载关系，不同作用域内的同名函数会造成遮蔽，使外层函数无效。

	![C++ 类继承时作用域嵌套关系](http://c.biancheng.net/cpp/uploads/allimg/161011/1-16101109445V06.jpg)
	
### C++ 继承时的对象内存模型

1. 当不存在继承时，对象内存模型很简单。成员变量和成员函数分开存储。**对象的内存**中只包含**成员变量**，存储在**栈区或堆区**。**成员函数**与对象内存分离，存储在**代码区**。
2. 存在继承关系时，派生类的内存模型可以看成是**基类成员变量**和**新增成员变量**的**总和**。而所有**成员函数**仍然存储在**代码区**，由**所有对象共享**。在内存中**基类**的成员变量排在**前面**，**派生类**的排在**后面**。例如：
	```c++
	class A {
	public:
		A(int a, int b);
		void Display();
	protected:
		int a_;
		int b_;
	};
	// class A定义略
	class B: public A {
	public:
		B(int a, int b, int c);
		void Display();
	private:
		int c_;
	};
	// class B定义略
	int main() {
		A obj_a(99, 10);
		B obj_b(23, 23, 34);
		return 0;
	}
	```
	`obj_a`和`obj_b`对象的内存分布如图所示。
	
	![继承中对象的内存模型](http://c.biancheng.net/cpp/uploads/allimg/150911/1-15091110245Y51.jpg)
	
3. 当父类的成员变量被**遮蔽**时，仍然会**留在派生类对象的内存**中，派生类新增的成员变量始终排在基类后面。在派生类的对象模型中，会包含所有基类的成员变量。这种设计方案的优点是**访问效率高**，能够在**派生类对象**中直接访问**基类变量**，无需经过好几层间接计算。

### 派生类的构造函数

1. 类的构造函数**不能**被继承。
2. 在派生类的构造函数中必须调用基类的构造函数。如果基类构造函数是默认的，则会自动调用；否则必须手动调用。
3. 基类构造函数的**调用**只能放在**派生类构造函数头部**（也就是函数定义的第一行），不能放在函数体中。以下代码中People是Student的基类。另外函数头部是对基类构造函数的**调用**，而不是声明，所以括号里的参数是**实参**，不但可以是派生类构造函数参数列表中的参数，还可以是局部变量、常量等。
	```c++
	Student::Student(string name, int age, float score): People("小明", 16), m_score(score) { }
	```
4. 构造函数的调用顺序是按照继承的层次**自顶向下**、**从基类到派生类**。
5. 派生类**构造函数**中只能调用**直接基类**的构造函数，不能调用间接基类。

### 派生类的析构函数

1. 和构造函数类似，析构函数也**不能**被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类**只有一个析构函数**，编译器知道如何选择，无需程序员干涉。
2. 销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即**先执行派生类析构函数**，再执行基类析构函数。

### 类的多继承

1. C++ 支持多继承，一个派生类可以有两个或多个基类。

  > 多继承容易让代码逻辑复杂，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。

2. 多继承的语法，将多个基类用逗号隔开即可。
	```c++
	class D: public A, private B, protected C {
		// 类D的成员
	}
	```
3. 多继承下的构造函数的调用顺序和它们在**派生类构造函数**中出现的**顺序无关**，而是和**声明派生类和基类出现的顺序相同**。析构函数也一样，调用顺序与**声明派生类和基类出现的顺序相反**。
4. 当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上**类名**和**域解析符`::`** ，以显式地指明到底使用哪个类的成员，消除二义性。

### C++ 多继承时的对象内存模型

1. 基类对象的排列顺序和继承时**声明**的顺序相同。
	```c++
	// 基类A
	class A {
		// ...
	}
	// 基类B
	class B {
		// ...
	}
	// 派生类C
	class A: public: A, public B {
	public:
		C(int a, int b, int c, int d): B(c, d), A(a, b) { }
	}
	int main() {
		C obj_c(10, 20, 30, 40);
	}
	```
	最后结果如下：
	
	![多继承对象内存模型](http://c.biancheng.net/cpp/uploads/allimg/150911/1-150911200I1310.jpg)
	
### 借助指针突破访问权限的限制

1. C++ 对private, protected属性的成员变量访问限制仅仅是语法层面的，可以通过**指针**突破访问权限的限制。

### 虚继承和虚基类

1. 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承（Virtual Inheritance），使得在派生类中只保留**一份**间接基类的成员。在继承方式前面加上`virtual`关键字就是虚继承。
	```c++
	//间接基类A
	class A{
	protected:
		int m_a;
	};
	//直接基类B
	class B: virtual public A{  //虚继承
	protected:
		int m_b;
	};
	//直接基类C
	class C: virtual public A{  //虚继承
	protected:
		int m_c;
	};
	//派生类D
	class D: public B, public C{
	public:
		void seta(int a){ m_a = a; }  //正确
		void setb(int b){ m_b = b; }  //正确
		void setc(int c){ m_c = c; }  //正确
		void setd(int d){ m_d = d; }  //正确
	private:
		int m_d;
	};
	int main(){
		D d;
		return 0;
	}
	```
	使用这种虚继承的方式实现菱形继承，在派生类D中只保留一份成员变量`m_a`，直接访问就不会再有歧义了。
2. 不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。

### 虚继承时的构造函数

1. 在虚继承中，虚基类是由**最终的派生类**初始化的。也就是说，最终派生类的构造函数必须要调用**虚基类的构造函数**。对最终的派生类来说，虚基类是**间接基类**，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用**直接基类**的构造函数，不能调用间接基类的。例如以下代码：
	```c++
	class A {
	public:
		A(int a);
	protected:
		int m_a;
	};
	A::A(int a) : m_a(a) {}
	class B: virtual public A {
	public:
		B(int a, int b);
	protected:
		int m_b;
	};
	B::B(int a, int b) : A(a), m_b(b) {}
	class C: virtual public A {
	public:
		C(int a, int c);
	protected:
		int m_c;
	};
	C::C(int a, int c) : A(a), m_c(c) {}
	class D: public B, public C {
	public:
		D(int a, int b, int c, int d);
	private:
		int m_d;	
	};
	D::D(int a, int b, int c, int d) : A(a), B(90, b), C(100, c), m_d(d) {}
	int main() {
	    B b(10, 20);
		C c(30, 40);
		D d(50, 60, 70, 80);
		return 0;
	}
	```
	在以上代码中，在D初始化时，`m_a`是由**D**的初始化函数初始化的，与B，C的初始化函数中的初始化值（90和100）无关。
2. 虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用**虚基类**的构造函数，再按照**出现的顺序**调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。

### 虚继承下的内存模型
1. 虚继承和普通继承相反，大部分编译器会把基类成员变量放在派生类成员变量的**后面**，这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量。例如以下代码
	```c++
	class A {}
	class B: virtual public A {}
	class C: virtual public B {}
	class D: public C {}
	```
	A是B的虚基类，B又是C的虚基类，那么各个对象的内存模型如下图所示：
	
	![虚继承的内存模型](http://c.biancheng.net/cpp/uploads/allimg/150915/1-15091520200R52.jpg)
	
	从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分：
	​	+ 不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为**固定部分**；
	​	+ 带有阴影的一部分是**虚基类的子对象**，偏移量会随着继承层次的增加而改变，称为**共享部分**。

2. 不同编译器对计算共享部分偏移的方法有不同的实现。
	+ cfront解决方法：在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。
	
	![cfront计算共享部分偏移](http://c.biancheng.net/cpp/uploads/allimg/150915/1-1509151J044P3.jpg)
	
	+ VC在cfront上进行了改进，一定程度弥补了它的不足。
	VC 引入了**虚基类表**，如果某个派生类有一个或多个虚基类，编译器就会在**派生类对象**中安插一个指针，指向**虚基类表**。虚基类表其实就是一个**数组**，数组中的元素存放的是**各个虚基类的偏移**。
	
	![VC计算共享部分偏移1](http://c.biancheng.net/cpp/uploads/allimg/150915/1-15091519111R32.jpg)
	
	假设A是B的虚基类，同时B又是C的虚基类，那么各对象的内存模型如下图所示：
	
	![VC计算共享部分偏移2](http://c.biancheng.net/cpp/uploads/allimg/150915/1-150915201003P8.jpg)
	
	虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于**当前对象**的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针。
	
### C++ 向上转型（Upcasting）

1. 类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。
2. 向上转型非常**安全**，可以由**编译器**自动完成；向下转型有风险，需要程序员手动干预。
3. 赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了**成员变量**，所以对象之间的赋值是成员变量的赋值，**成员函数不存在赋值问题**。对象之间的赋值不会影响成员函数，也不会影响`this`指针。
4. 将派生类对象赋值给基类对象时，会**舍弃**派生类新增的成员。这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。

	![派生类对象赋值给基类对象](http://c.biancheng.net/cpp/uploads/allimg/150831/1-150S121411IQ.png)
	
5. 除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。赋值时，基类对象的指针必须指向子对象中的**偏移起始位置**。例如下图这种多继承关系：
	
	![多继承关系](http://c.biancheng.net/cpp/uploads/allimg/161023/1-161023202054F5.jpg)
	
	将指向D对象的指针赋值给C对象指针时，编译器会进行调整：
	```c++
	pc = (C*)( (int)pd + sizeof(B) );
	```
	从而将指针偏移至C类子对象的起始位置。如下图。
	
	![指针赋值偏移](http://c.biancheng.net/cpp/uploads/allimg/161025/1-16102511030U35.jpg)
	
6. 将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的**成员变量**，但**不能**使用派生类的**成员函数**。这是由于赋值时使得隐式指针`this`发生了变化，也指向了派生类对象，因此最终使用的是**派生类对象**的成员变量。但是，在编译时，成员函数已经全部进行了**名字编码**，被编译成与对象无关的全局函数（即已经明确了函数的定义），因此调用的还是**基类对象**的成员函数。
7. 将派生类引用赋值给基类引用时，由于引用的本质就是指针，因此基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。
8. 向上转型后通过基类的对象、指针、引用只能访问从基类**继承过去的成员**（包括成员变量和成员函数），**不能**访问派生类**新增的成员**。

## 多态性与虚函数

### 多态的概念以及用途

1. 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。为了让基类指针能够访问派生类的成员函数，C++ 增加了**虚函数（virtual function）**。只需要在函数声明前面增加**virtual**关键字。
2. 多态是面向对象编程的主要特征之一，C++ 中虚函数的唯一用处就是**构成多态**。
3. C++提供多态的目的是：可以通过**基类指针**对所有派生类（包括直接派生和间接派生）的**成员变量**和**成员函数**进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。
4. 借助引用也可以实现多态。不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。
5. 使用多态只需要一个指针变量，就可以调用所有派生类的虚函数。详见[C++ 多态的概念以及用途](http://c.biancheng.net/cpp/biancheng/view/2987.html)中多态的用途代码。

### 虚函数详解

1. 虚函数对于多态具有决定性的作用，有虚函数才能构成多态。虚函数注意事项如下：
	+ 只需要在虚函数的**声明**处加上**virtual**关键字，函数定义处可以加也可以不加。
	+ 为了方便，可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的**同名函数**都将**自动成为虚函数**。
	+ 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用**基类**的虚函数。
	+ 只有派生类的虚函数**遮蔽**基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为`virtual void func();`，派生类虚函数的原型为`virtual void func(int);`，那么当基类指针p指向派生类对象时，语句`p -> func(100);`将会出错，而语句`p -> func();`将调用基类的函数。
	+ 构造函数**不能是虚函数**。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。
	+ 析构函数**可以**声明为虚函数，而且有时候必须要声明为虚函数。
2. 构成多态的条件：
	+ 必须存在**继承关系**。
	+ 继承关系中必须有**同名的虚函数**，并且它们是**遮蔽关系**。
	+ 存在**基类的指针**，通过该指针调用虚函数。
	
3. 什么时候声明虚函数？首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。

### 虚析构函数的必要性

1. 使用**基类指针**指向**派生类**时，如果析构函数是**非虚函数**，通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针指向哪个类就调用哪个类的函数，那么**派生类的析构函数**永远不会调用，也就会导致派生类实例化时创建的局部变量永远得不到释放，导致内存泄露。
2. 将基类的析构函数声明为**虚函数**后，**派生类**的析构函数也会**自动成为虚函数**。这个时候编译器会**忽略指针的类型**，而根据**指针的指向**来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。大部分情况下都应该将**基类的析构函数**声明为虚函数。

### 纯虚函数和抽象类

1. 在C++中，可以将虚函数声明为纯虚函数，语法格式为：
  ```c++
  virtual 返回值类型 函数名 (函数参数) = 0;
  ```
  纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上`=0`，表明此函数为纯虚函数。

  > 最后的=0并不表示函数返回值为0，它只起到形式上的作用，告诉编译系统“这是纯虚函数”。

2. 包含纯虚函数的类称为**抽象类（Abstract Class）**。之所以说它抽象，是因为它**无法实例化**，也就是无法创建对象。原因很明显，纯虚函数**没有函数体**，不是完整的函数，**无法调用**，也无法为其**分配内存空间**。
3. 抽象类通常是作为**基类**，让派生类去实现纯虚函数。派生类**必须实现纯虚函数**才能被实例化。
4. 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。
5. 只有**类中的虚函数**才能被声明为纯虚函数，**普通成员函数和顶层函数**均不能声明为纯虚函数。

### 虚函数表，多态的实现机制

1. 在通过指针访问类的成员函数时，如果该函数是虚函数，并且派生类有同名的函数遮蔽它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数。这就是多态。编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了**虚函数表**。
2. 如果一个类包含了虚函数，那么在创建该类的对象时就会额外创建一个数组，数组中每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个**指针**，指向**数组的起始位置**。这里的数组就是**虚函数表（Virtual function table）**，简写为**vtable**。
3. 虚函数表与各个对象内存模型如下所示（详细代码见[虚函数表](http://c.biancheng.net/cpp/biancheng/view/3006.html)）。

	![虚函数表内存模型](http://c.biancheng.net/cpp/uploads/allimg/161029/1-161029110543X5.jpg)
	
	图中左半部分是对象占用的内存，右半部分是虚函数表`vtable`。在对象的开头位置有一个指针`vfptr`，指向虚函数表，并且这个指针始终位于**对象的开头位置**。**基类的虚函数**在`vtable`中的索引（下标）是**固定**的，不会随着继承层次的增加而改变，派生类新增的虚函数放在`vtable`的**最后**。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用**派生类的虚函数**替换基类的虚函数，这样具有遮蔽关系的虚函数在`vtable`中只会出现一次。当通过指针调用虚函数时，先根据指针找到`vfptr`，再根据 `vfptr`找到虚函数的入口地址。

### typeid运算符

1. `typeid`运算符用来获取一个表达式的类型信息。类型信息主要分为以下两类：
	+ 对于**基本类型**（int、float 等C++ 内置类型）的数据，类型信息所包含的内容比较简单，主要是指**数据的类型**。
	+ 对于**类类型的数据（也就是对象）**，类型信息是指**对象所属的类**、**所包含的成员**、**所在的继承关系**等。
2. 类型信息是创建数据的**模板**，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。
3. `typeid`的操作对象既可以是表达式，也可以是数据类型。
4. `typeid`会把获取到的类型信息保存到一个`type_info`类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过**成员函数**来提取。
5. C++ 标准规定，`type_info`类至少要有如下所示的4个`public`属性的成员函数，其他的扩展函数编译器开发者可以自由发挥，不做限制。
	+ `const char* name() const;`
		返回一个能表示类型名称的字符串。但是C++ 标准并没有规定这个字符串是什么形式的。
	+ `bool before (const type_info& rhs) const;`
		判断一个类型是否位于另一个类型的前面，`rhs`参数是一个`type_info`对象的引用。但是C++标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义。要特别注意的是，这个排列顺序和继承顺序没有关系，基类并不一定位于派生类的前面。
	+ `bool operator == (const type_info& rhs) const;`
		重载运算符`==`，判断两个类型是否相同，`rhs`参数是一个`type_info`对象的引用。
	+ `bool operator != (const type_info& rhs) const;`
		重载运算符`!=`，判断两个类型是否不同，`rhs`参数是一个`type_info`对象的引用。
6. 与Java、C# 等动态性较强的语言，C++ 能获取到的类型信息非常有限，也没有统一的标准，大部分情况下我们只是使用重载过的`==`运算符来判断两个类型是否相同。
7. `typeid`运算符经常用来判断两个类型是否相等。
	比如：
	```c++
	char* str;
	int a = 2;
	int b = 10;
	float f;
	
	typeid(int) == typeid(int); // true
	typeid(char*) == tpyeid(str); // true
	typeid(a/b) == typeid(int); // true
	typeid(char*) == typeid(char); // false
	```
8. 为了减小编译后文件的体积，编译器不会为所有的类型创建`type_info`对象，只会为**使用了`typeid`运算符**的类型创建。不过有一种特殊情况，就是**带虚函数的类**（包括继承来的），不管有没有使用`typeid`运算符，编译器都会为带虚函数的类创建`type_info`对象。
9. 类的比较。如下
	```c++
	class Base {};
	class Derived: public Base {};
	
	Base obj1;
	Base *p1;
	Derived obj2;
	Derived *p2 = new Derived;
	p1 = p2;
	
	typeid(obj1) == typeid(p1); // false
	typeid(&obj1) == typeid(p1); // true
	typeid(obj1) == typeid(*p1); // true
	typeid(obj1) == typeid(obj2); // false
	typeid(p1) == typeid(Derived*); // false
	typeid(*p1) == typeid(Base); // true
	```

### RTTI机制（Run-Time Type Identification）- 运行时类型识别

1. 如果类包含了虚函数，那么该类的对象内存中还会额外增加类型信息，也即 **`type_info`对象**。例如以下代码：
	```c++
	//基类
	class Base{
	public:
		virtual void func();
	protected:
		int m_a;
		int m_b;
	};
	void Base::func(){ cout<<"Base"<<endl; }
	
	//派生类
	class Derived: public Base{
	public:
		void func();
	private:
		int m_c;
	};
	void Derived::func(){ cout<<"Derived"<<endl; }
	
	int main() {
		Base *p;
		int n;

		cin>>n;
		if(n <= 100){
			p = new Base();
		}else{
			p = new Derived();
		}
		cout<<typeid(*p).name()<<endl;
		return 0;
	}
	```
	`Base`和`Derived`的对象内存模型如下图所示：
	
	![type_info类对象](http://c.biancheng.net/cpp/uploads/allimg/161109/1-1611091006342S.jpg)
	
	编译器会在虚函数表`vftable`的开头插入一个指针，指向当前类对应的`type_info`对象。当程序在运行阶段获取类型信息时，可以通过对象指针`p`找到虚函数表指针`vfptr`，再通过`vfptr `找到`type_info`对象的指针，进而取得类型信息。下面的代码演示了这种转换过程：
	```c++
	**(p->vfptr - 1);
	```
	程序运行后，不管`p`指向`Base`类对象还是指向`Derived`类对象，只要执行这条语句就可以取得`type_info`对象。
	
2. 编译器在编译阶段无法确定`p`指向哪个对象，也就无法获取`*p`的类型信息，但是编译器可以在编译阶段做好各种准备，这样程序在运行后可以借助这些准备好的数据来获取类型信息。这些准备包括：
	+ 创建`type_info`对象，并在`vftable`的开头插入一个指针，指向`type_info`对象。
	+ 将获取类型信息的操作转换成类似`**(p->vfptr - 1)`这样的语句。
	这种在程序运行后确定对象的类型信息的机制称为**运行时类型识别（Run-Time Type Identification，RTTI）**。在C++ 中，只有类中包含了**虚函数**时才会启用 RTTI 机制，其他所有情况都可以在编译阶段确定类型信息。
	
### 静态绑定和动态绑定

1. C/C++ 用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到**内存**中才能供CPU使用。CPU通过**地址**来取得内存中的代码和数据，程序在执行过程中会告知CPU要执行的代码以及要读写的数据的地址。变量名和函数名只是地址的一种**助记符**，当源文件被编译和链接成可执行程序后，它们**都会被替换成地址**。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
2. 我们不妨将变量名和函数名统称为**符号（Symbol）**，找到符号对应的地址的过程叫做**符号绑定**。
3. 函数调用实际上是执行函数体中的代码。**函数体**是内存中的一个**代码段**，**函数名**就表示该代码段的**首地址**，函数执行时就从这里开始。说得简单一点，就是必须要知道函数的**入口地址**，才能成功调用函数。找到函数名对应的地址，然后将函数调用处用该地址替换，这称为**函数绑定**。
4. 一般情况下，在**编译期间（包括链接期间）**就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。这称为**静态绑定（Static binding）**。
5. 但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序**运行**后根据具体的环境或者用户操作才能决定。这称为**动态绑定（dynamic binding）**。例如上面RTTI一节中的代码，就是动态绑定。

### RTTI机制下的对象内存模型

1. 要能够判断一个类是否是另一个类的基类，必须要在基类和派生类之间再增加一条绳索，把它们连接起来，形成一条通路，让程序在各个对象之间游走。在面向对象的编程语言中，我们称此为**继承链（Inheritance Chain）**。
2. 将基类和派生类连接起来很容易，只需要在基类对象中增加一个指向派生类对象的指针，然而考虑到多继承、降低内存使用等诸多方面的因素，真正的对象内存模型比上节讲到的要复杂很多，并且不同的编译器有不同的实现。
3. 以下展示了`Visual C++`下真正的内存模型：
	```c++
	class A{
	protected:
		int a1;
	public:
		virtual int A_virt1();
		virtual int A_virt2();
		static void A_static1();
		void A_simple1();
	};
	class B{
	protected:
		int b1;
		int b2;
	public:
		virtual int B_virt1();
		virtual int B_virt2();
	};
	class C: public A, public B{
	protected:
		int c1;
	public:
		virtual int A_virt2();
		virtual int B_virt2();
	};
	```
	
	![Visual C++ 内存模型](http://c.biancheng.net/cpp/uploads/allimg/150919/1-150919151300611.jpg)
	
4. 在`C/C++`中，**变量、函数参数、函数返回值**等在**定义**时都必须**显式地指明类型**，并且一旦指明类型后就**不能再更改**了，所以大部分表达式的类型都能够精确的推测出来，编译器在**编译期间**就能够搞定这些事情，这样的编程语言称为**静态语言（Static Language）**。除了`C/C++`，典型的静态语言还有Java、`C#`、`Haskell`、`Scala`等。
5. 与静态语言相对的是**动态语言（Dynamic Language）**。动态语言在定义变量时往往**不需要指明类型**，并且变量的类型可以随时改变（赋给它不同类型的数据），编译器在编译期间也不容易确定表达式的类型信息，只能等到程序**运行**后再动态地获取。典型的动态语言有`JavaScript、Python、PHP、Perl、Ruby`等。
6. 动态语言为了能够使用灵活，部署简单，往往是一边编译一边执行，模糊了传统的编译和运行的过程。

## C++ 模版

### 函数模版

1. 在C++ 中，数据的**类型**也可以通过**参数**来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据**传入的实参**自动推断数据类型。这就是类型的参数化。**值（Value）**和**类型（Type）**是数据的两个主要特征，它们在C++中都可以被**参数化**。
2. 所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个**标识符来占位**），等发生函数**调用**时再根据传入的实参来逆推出真正的类型。这个通用函数就称为**函数模板（Function Template）**。示例代码如下：
	```c++
	template<typename T> void Swap(T *a, T *b){
		T temp = *a;
		*a = *b;
		*b = temp;
	}
	```
	`template<typename T>`被称为**模板头**。占位符可以用**typename**也可以用**class**。模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体。

### C++ 类模版

1. C++ 除了支持函数模板，还支持**类模板（Class Template）**。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的**类型参数**可以用在**类声明**和**类实现**中。类模板的目的同样是将数据的类型参数化。语法如下：
	```c++
	template<typename 类型参数1, typename 类型参数2> class 类名 {
		// TODO;
	};
	```
	占位符可以用typename也可以用class。类型参数不能为空，多个类型参数用**逗号**隔开。注意：在类外**定义**成员函数时仍然需要带上模板头。

2. 类模版中函数定义时，类名后面也要带上**类型参数**，只是不加`typename`关键字了。另外需要注意的是，在**类外定义成员函数**时，template后面的类型参数要和**类声明**时的一致。例如：
	```c++
	// Point后面必须加上类型参数
	template<typename T1, typename T2>  //模板头
	T1 Point<T1, T2>::getX() const /*函数头*/ {
		return m_x;
	}
	```
	
3. 使用类模版创建对象时，必须**显式地指明数据类型**，编译器不能根据给定的数据推演出数据类型，且要**保持一致**。例如：
	```c++
	Point<int, int> p1(10, 20);
	Point<int, float> p2(10, 15.5);
	Point<char*, char*> *p = new Point<char*, char*>("东经180度", "北纬210度");

	Point<float, float> *p = new Point<float, int>(10.6, 109); // 编译错误，赋值号两边的数据类型不一致
	```

### 模版编程

1. 强类型语言与弱类型语言
	+ 强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能赋予其他类型的数据了，除非经过强制类型转换或隐式类型转换。典型的强类型语言有`C/C++、Java、C#`等。`Java`对类型转换的要求比`C/C++`更为严格，隐式转换只允许由低向高转，由高向低转必须强制转换。

	+ 弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据。典型的弱类型语言有`JavaScript、Python、PHP、Ruby、Shell、Perl`等。

*也有另一种说法，强类型与弱类型的区别是是否会经常进行**隐式类型转换**，按照这个标准。Python应该是强类型语言。例如在Python中，输入以下代码会抛出error，而在JavaScript中不会。*
```
i = 3;
str = "test";
str + i;  // Python抛出error,js输出"3test"
```

2. 不管是强类型语言还是弱类型语言，在编译器（解释器）内部都有一个**类型系统**来维护变量的各种信息。对于强类型的语言，变量的类型从始至终都是**确定的、不变的**，编译器在**编译**期间就能检测某个变量的操作是否正确，这样最终生成的程序中就不用再维护一套类型信息了，从而**减少了内存的使用**，加快了程序的运行。
3. 对于弱类型的语言，变量的类型可以**随时改变**，赋予它什么类型的数据它就是什么类型，编译器在编译期间不好确定变量的类型，只有等到程序**运行**后、真的赋给变量一个值了，才能确定变量当前是什么类型，所以传统的编译对弱类型语言意义不大，因为即使编译了也有很多东西确定不下来。
4. 模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为**泛型编程（Generic Programming）**。可以将参数T看作是一个**泛型**。

### 函数模版的重载

1. 在C/C++ 中，作为“类型的数组”的形参会被调整为“类型的指针”，编译器只向函数传递数组的地址，而不是整个数组的拷贝。也就是说下面三种形式的函数定义是等价的：
	```c++
	void func(int *parr) {}
	void dunc(int arr[]) {}
	void func(int arr[5]) {}
	```
	在函数内部，`arr`会被转换成一个指针变量，编译器为`arr`分配4个字节的内存，用 `sizeof(arr)`求得的是**指针变量**的长度，而不是数组长度。因此要想在函数内部获得数组长度必须**额外增加一个参数**，在**调用函数之前**求得数组长度。
2. 并非所有的类型都使用同一种算法，有些特定的类型需要单独处理，为了满足这种需求，C++  允许对函数模板进行**重载**，程序员可以像重载常规函数那样重载模板定义。例如使用模版交换两个对象的模版中，当传入的是数组类型时，由于函数形参中数组类型会被转化成指针，因此交换时会发生错误。交换两个数组唯一的办法就是逐个交换所有的数组元素，必须对原来的模版进行重载，详见[C++ 函数模板的重载](http://c.biancheng.net/cpp/biancheng/view/3270.html)。

### 函数模版的实参推断

1. 在使用**类模板**创建对象时，程序员需要**显式**的指明实参（也就是具体的类型）。而对于**函数模板**，调用函数时可以**不显式**地指明实参（也就是具体的类型）。
2. 对于普通函数（非模版函数），发生函数调用时会对实参的类型进行适当的转换，以适应形参的类型。这些转换包括：
	+ 算法转换：例如`int`转换为`float`，`char`转换为`int`，`double`转换为`int`等。
	+ 派生类向基类的准换：向上转型（upcasting）。
	+ `const`转换：也即将非`const`类型转换为`const`类型，例如将`char *`转换为`const char *`。
	+ 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
	+ 用户自定的类型转换。
3. 对于函数模版，类型转换受到了更多的限制，仅能够进行**const转换**和**数组或函数指针转换**，其他的转换都不能应用于函数模版。
4. 如果编译器不能从函数调用中推断出类型参数，则必须在**调用**时**显式**地指明实参类型。指明实参的形式与在类模版中指明实参的方式是类似的。例如：
	```c++
	template<typename T1, typename T2> void func(T1 a) {
		T2 b;
	}
	
	func(10); // compile error
	func<int, float> (10); // 调用成功
	```
	> 注：在[函数模版的实参推断](http://c.biancheng.net/cpp/biancheng/view/3277.html)中，作者表示显式指明的模板实参会按照从左到右的顺序与对应的模板参数匹配：第一个实参与第一个模板参数匹配，第二个实参与第二个模板参数匹配，以此类推。只有尾部（最右）的类型参数的实参可以省略，而且前提是它们可以从传递给函数的实参中推断出来。但经过在`g++`的测试，在推断不出的情况下，必须在调用时指明**全部参数**的类型。

### 模版的显式具体化

1. 在调用函数时，非模版函数、模版函数、显式具体化模版函数的调用顺序为：非模版函数 -> 显式具体化 -> 常规模版。
2. 在**类外**定义成员函数时，普通类模版的成员函数前要带上模版头，而**显式具体化**的**类模版成员函数**前面**不能**带模版头。
	```c++
	// 普通类模版成员函数
	template <class T1, class T2> //这里要带上模板头
	void Point<T1, T2>::display() const {}
	
	// 显式具体化类
	template <>
	class Point<string , string> {
	public:
		void display() const;
	};
	// 显式具体化类模版成员函数
	void Point<string , string>::display() const {}
	```
3. 在上面的显式具体化例子中，我们为所有的类型参数都提供了实参，所以最后的模板头为**空**，也即`template<>`。另外C++ 还允许只为一部分类型参数提供实参，这称为**部分显式具体化**。
4. 部分显式具体化只能用于**类模板**，不能用于函数模板。

### 模版中的非类型参数

1. 在将数组作为形参传递给函数时，由于作为**函数形参**的**数组**始终会被编译器修改成指向数组第一个元素的**指针**（不论传递的是数组名还是指针），因此一般要在函数中需要用到数组长度时，必须要另外传入一个参数，即计算好的数组长度。例如：
	```c++
	// 函数
	void Swap(int a[], int b[], int size) {}
	
	// 调用
	int a[6], b[6];
	int size = sizeof(a) / sizeof(int);
	```
2. 借助模板中的**非类型参数**，可以将必须传入函数的数组长度消除，请看下面的代码：
	```c++
	template<typename T, unsigned N> void Swap(T (&a)[N], T(&b)[N]) {}
	```
	`T (&a)[N]`表明`a`是一个引用，它引用的数据的类型是`T[N]`，也即一个数组。而使用了`unsigned N`定义，在调用时编译器会用数组类型`int`代替类型参数`T`，例如：
	```c++
	int a[5] = {1, 2, 3, 4, 5};
	int b[5] = {6, 7, 8, 9, 10};
	Swap(a, b);
	```
	编译器就会用数组长度5来代替非类型参数N。
3. 非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个**整数**，或者是一个指向对象或函数的**指针（也可以是引用）**。
4. 当非类型参数是一个**整数**时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如`10`，`2 * 30`，不能是`n`，`n + m`。
5. 当非类型参数是一个**指针（引用）**时，绑定到该指针的实参必须具有**静态**的生存期；换句话说，实参必须存储在虚拟地址空间中的**静态数据区**。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。

### 模版的实例化

1. 模版（templete）不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模版**不会**占用内存，最终生成的函数或者类才会占用内存。由模板**生成函数或类的过程**叫做**模板的实例化（Instantiate）**，相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个**实例（Instantiation）**。
2. 模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。
3. 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。
4. 通过类模版创建对象时不会实例化所有成员函数，只有等到真正调用它们时才会被实例化。如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是**延迟的、局部的**。

### 将模版用于多文件编程

1. 由于类模版的实例化是**延迟的、局部的**，因此如果将模版的声明和定义放到不同的文件中，就可能出现模版实例化时找不到对应的定义。其根本原因是：模板的实例化是由**编译器**完成的，而不是由链接器完成的，这可能会导致在链接期间找不到对应的实例。因此，最好的做法是将模版的声明和定义都放到**头文件**中。

### 模版的显式实例化

1. 由**编译器自动完成**的模版实例化称为**隐式实例化**。通过代码明确地告诉编译器需要针对哪个类型进行实例化称为**显式实例化**。
2. 编译器在实例化的过程中需要知道模板的所有细节：对于**函数模板**，也就是**函数定义**；对于**类模板**，需要同时知道**类声明**和**类定义**。我们必须将**显式实例化的代码**放在包含了**模板定义的源文件**中，而不是仅仅包含了模板声明的头文件中。
3. 显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。
4. 函数模版的显式实例化示例：
	```c++
	template void Swap(double &a, double &b);
	```
	将原来用模版T表示的地方替换为要实例化具体的类型，并把`template`关键字后的`<typename T>`去掉。
	另外，还可以在包含了函数调用的源文件（main.cpp）中再增加下面的一条语句：
	```c++
	extern template void Swap(double &a, double &b);
	```
	该语句在前面增加了`extern`关键字，它的作用是明确地告诉编译器，该版本的函数实例在其他文件中，请在链接期间查找。不过这条语句是多余的，即使不写，编译器发现当前文件中没有对应的模板定义，也会自动去其他文件中查找。
5. 类模版的显式实例化
	与函数模版显式实例化类似。
	```c++
	template class Point<char*, char*>;
	```
	显式实例化一个类模板时，会一次性实例化该类的**所有成员**，包括成员变量和成员函数。
	
## C++ 面向对象进阶

### C++ 拷贝构造函数

1. 严格来说，对象的创建包括两个阶段，首先要**分配内存空间**，然后再进行**初始化**：
+ 分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。
+ 初始化就是**首次**对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。

	很明显，这里所说的拷贝是在**初始化**阶段进行的，也就是用其它对象的数据来初始化新对象的内存。

	当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是**拷贝构造函数（Copy Constructor）**。
	
2. 拷贝构造函数只有一个参数，它的类型是**当前类的引用**，而且一般都是**const 引用**。

	```c++
	class Student
	{
	public:
		Student(string name = "", int age  = 0, float score=0.0f);  // 普通构造函数
		Student(const Student &stu);  // 拷贝构造函数
	private:
		string m_name;
		int m_age;
		float m_score;
	};

	// 拷贝构造函数定义
	Student::Student(const Student &stu)
	{
		this->name = stu.m_name;
		this->m_age = stu.m_age;
		this->m_score = stu.m_score;
	}
	```

3. 编译器会自动生成一个默认的拷贝构造函数，对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数。

### 拷贝构造函数的调用时机

1. 在定义的同时进行赋值叫做**初始化（initialization）**，定义完成以后再赋值叫做**赋值（Assignment）**。
2. 类在初始化时会调用构造函数，而赋值时会调用重载过的赋值运算符。
3. 当函数的返回值为类类型时，return 语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。

### 深拷贝与浅拷贝

1. 对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。这种默认的拷贝行为就是浅拷贝，这和调用**memcpy()** 函数的效果非常类似。
2. 深拷贝的应用：变长数组、标准模板库（STL）中的 string、vector、stack、set、map。例如下面的变长数组示例代码。
	```c++
	#include <iostream>
	#include <cstdlib>
	using namespace std;
	//变长数组类
	class Array{
	public:
		Array(int len);
		Array(const Array &arr);  //拷贝构造函数
		~Array();
	public:
		int operator[](int i) const { return m_p[i]; }  //获取元素（读取）
		int &operator[](int i){ return m_p[i]; }  //获取元素（写入）
		int length() const { return m_len; }
	private:
		int m_len;
		int *m_p;
	};
	Array::Array(int len): m_len(len){
		m_p = (int*)calloc( len, sizeof(int) );
	}
	Array::Array(const Array &arr){  //拷贝构造函数
		this->m_len = arr.m_len;
		this->m_p = (int*)calloc( this->m_len, sizeof(int) );
		memcpy( this->m_p, arr.m_p, m_len * sizeof(int) );
	}
	Array::~Array(){ free(m_p); }
	//打印数组元素
	void printArray(const Array &arr){
		int len = arr.length();
		for(int i=0; i<len; i++){
			if(i == len-1){
				cout<<arr[i]<<endl;
			}else{
				cout<<arr[i]<<", ";
			}
		}
	}
	int main(){
		Array arr1(10);
		for(int i=0; i<10; i++){
			arr1[i] = i;
		}

		Array arr2 = arr1;
		arr2[5] = 100;
		arr2[3] = 29;

		printArray(arr1);
		printArray(arr2);

		return 0;
	}
	```

3. 如果一个类拥有**指针类型**的成员变量，那么绝大部分情况下需要深拷贝。

### 重载赋值运算符

1. 重载赋值运算符实例代码如下。
  ```c++
  class Array
  {
  public:
  	Array & operator=(const Array &arr);  //重载赋值运算符
  };
  ```


	Array &Array::operator=(const Array &arr)
	{
		if( this != &arr){  //判断是否是给自己赋值
			this->m_len = arr.m_len;
			free(this->m_p);  //释放原来的内存
			this->m_p = (int*)calloc( this->m_len, sizeof(int) );
			memcpy( this->m_p, arr.m_p, m_len * sizeof(int) );
		}
		return *this;
	}
	```
	`operator=()`的返回值类型为`Array &`，这样不但能避免在返回数据时调用拷贝构造函数，还能达到连续赋值的目的。

### C++ 拷贝控制操作（三/五法则）

1. 一个类通过定义三种特殊的成员函数来控制拷贝、赋值和销毁操作，分别是拷贝构造函数、赋值运算符和析构函数（三法则）。再加上移动构造函数和移动赋值运算符（C++ 11标准），称为（五法则）。
2. 需要**析构函数**的类也需要**拷贝**和**赋值**操作。
3. 需要**拷贝**操作的类也需要**赋值**操作，反之亦然。

### 转换构造函数

1. 转换构造函数只有一个参数。要将其他类型数据转换成**当前类类型**时使用。例如：
	```c++
	class Complex
	{
	public:
		Complex(double real): m_real(real) {}
	private:
		double m_real;
	};
	
	int main()
	{
		Complex a = 200.2;  // 调用转换构造函数，将double转换为Complex类型
		return 0;
	}
	```
2. 可以借助函数的**默认参数**，将多个构造函数简化为一个。

### 类型转换函数

1. C++ 提供了**类型转换函数（Type conversion function）**来将当前类类型转换为其它类型。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以**成员函数**的形式出现，也就是只能出现在类中。类型转换函数也**没有参数**。语法格式为：

	```c++
	operator type()
	{
		// TODO
		return data;	
	}
	```
	`operator`是关键字，type是要转换的目标类型（比如int, double），data是要返回的type类型数据。示例代码如下：
	```c++
	class Complex
	{
	public:
		operator double() const { return m_real; }
	private:
		double m_real;
	};
	```
	
2. 类型转换函数的说明：
	+ type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，**不允许**转换为**数组**或**函数类型**，转换为指针类型或引用类型是可以的。
	+ 类型转换函数一般不会更改被转换的对象，所以通常被定义为 **const**成员。
	+ 类型转换函数可以**被继承**，可以是**虚函数**。

3. 一般而言，同时使用转换构造函数和类型转换函数有可能会产生**二义性**问题。一般解决办法是只使用**转换构造函数**，而想将当前类型转换为其他类型时，使用普通的成员函数取值或转换。

### 类型转换的本质

1. 类型转换的本质是对内存中同一区域二进制数据**解释方式**的转换。比如变量原来是`int`类型，那么对变量对应内存区域的数据解释为int。转换为float时，则将这一内存区域数据解释为float。
2. 对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要**修改数据的二进制位**；而对于强制类型转换，没有对应的转换规则，只是重新解释二进制位，无法做出修正。

### C++ 四种类型转换运算符

1. 为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持。语法如下：
	```c++
	xxx_cast<newType>(data)
	```
	newType是要转换成的新类型，data是要被转换的数据。
	
2. `static_cast`
	+ 用于**良性转换**
	+ 原有的自动类型转换，如short转int, int转double, const转非const, 向上转型等
	+ void 指针和具体类型指针之间的转换，例如`void *`转`int *`、`char *`转`void *`等
	+ 有转换构造函数或者类型转换函数的类与其它类型之间的转换
	+ `static_cast` 是“静态转换”的意思，也就是在**编译期间**转换，转换失败的话会抛出一个编译错误

3. `const_cast`
	+ 用来将 const/volatile 类型转换为非 const/volatile 类型
	+ 使用 `const_cast` 进行强制类型转换可以突破 `C/C++` 的常数限制，修改常数的值

4. `reinterpret_cast`
	+ 仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整
	+ 可以认为是`static_cast`的一种补充，一些`static_cast`不能完成的转换，就可以用`reinterpret_cast`来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换

5. `dynamic_cast`
	+ 用于在类的继承层次之间进行类型转换
	+ 既允许向上转型（Upcasting），也允许向下转型（Downcasting）
	+ `dynamic_cast`会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数
	+ dynamic_cast 只能转换**指针类型**和**引用类型**，其它类型（int、double、数组、类、结构体等）都不行